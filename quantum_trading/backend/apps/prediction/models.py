# apps/prediction/models.py
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from core.models.market_data import Asset, MarketData
from core.models.signals import TradingSignal, PredictionEngine

class QuantumEngineConfig(models.Model):
    """
    Configuration for your Quantum-Charged prediction engine
    Stores all parameters from your Streamlit sidebar and algorithms
    """
    name = models.CharField(max_length=100, default="Quantum-Charged Engine v1.0")

    # Base Parameters (from your Streamlit sidebar)
    base_window_size = models.PositiveIntegerField(
        default=20,
        validators=[MinValueValidator(10), MaxValueValidator(50)],
        help_text="Base window size for MA-DFA calculation"
    )
    particle_count = models.PositiveIntegerField(
        default=100,
        validators=[MinValueValidator(50), MaxValueValidator(500)],
        help_text="Number of particles for particle filter"
    )
    hurst_threshold = models.DecimalField(
        max_digits=5, decimal_places=3,
        default=0.65,
        validators=[MinValueValidator(0.5), MaxValueValidator(0.8)],
        help_text="Base Hurst threshold for regime detection"
    )

    # Advanced Quantum Parameters
    volatility_entropy_weight = models.DecimalField(max_digits=5, decimal_places=3, default=1.0)
    fractal_dimension_weight = models.DecimalField(max_digits=5, decimal_places=3, default=1.0)
    quantum_chaos_parameter = models.DecimalField(max_digits=5, decimal_places=3, default=4.0)  # Logistic map 'r'
    learning_rate = models.DecimalField(max_digits=5, decimal_places=4, default=0.01)  # QCO eta

    # Trading Strategy Parameters
    volatility_threshold_quantile = models.DecimalField(
        max_digits=5, decimal_places=3, default=0.75,
        help_text="Quantile for volatility threshold (from your strategy)"
    )
    fpn_confidence_threshold = models.DecimalField(
        max_digits=5, decimal_places=3, default=0.7,
        help_text="Confidence threshold for FPN-DRL signals"
    )

    # Model Performance Tracking
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'quantum_engine_config'
        verbose_name = 'Quantum Engine Configuration'
        verbose_name_plural = 'Quantum Engine Configurations'

class QuantumPrediction(models.Model):
    """
    Stores predictions generated by your quantum algorithm
    Each prediction corresponds to your Streamlit analysis for a specific asset/date
    """
    asset = models.ForeignKey(Asset, on_delete=models.CASCADE, related_name='quantum_predictions')
    market_data = models.ForeignKey(MarketData, on_delete=models.CASCADE, related_name='quantum_analysis')
    engine_config = models.ForeignKey(QuantumEngineConfig, on_delete=models.CASCADE)

    # Timestamp for this prediction
    prediction_timestamp = models.DateTimeField(db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)

    # === MA-DFA CALCULATIONS (from your calculate_ma_dfa function) ===
    hurst_exponent = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="MA-DFA Hurst exponent"
    )
    fluctuation = models.DecimalField(
        max_digits=15, decimal_places=6, null=True, blank=True,
        help_text="DFA fluctuation value"
    )
    volatility_entropy = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Calculated volatility entropy"
    )
    fractal_dimension = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Fractal dimension (2 - Hurst)"
    )
    adaptive_window_size = models.PositiveIntegerField(
        null=True, blank=True,
        help_text="Adaptive window size used in calculation"
    )

    # === ASYMMETRIC MA-DFA (from your calculate_amfdfa function) ===
    hurst_uptrend = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Hurst exponent for uptrend regimes"
    )
    hurst_downtrend = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Hurst exponent for downtrend regimes"
    )
    regime_detection = models.CharField(
        max_length=10,
        choices=[('UPTREND', 'Uptrend'), ('DOWNTREND', 'Downtrend'), ('NEUTRAL', 'Neutral')],
        default='NEUTRAL'
    )

    # === PARTICLE FILTER VOLATILITY (from your calculate_particle_volatility) ===
    particle_volatility = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Particle filter volatility estimate"
    )
    realized_semivariance_up = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="RSV_Up from your calculation"
    )
    realized_semivariance_down = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="RSV_Down from your calculation"
    )
    particle_weights_entropy = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Entropy of particle weights"
    )

    # === QUANTUM CHAOS OPTIMIZATION (from your qco_tune function) ===
    dynamic_hurst_threshold = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="QCO-tuned Hurst threshold"
    )
    chaos_parameter = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Current chaotic state (x from logistic map)"
    )
    quantum_entropy = models.DecimalField(
        max_digits=10, decimal_places=6, null=True, blank=True,
        help_text="Quantum-inspired entropy measure"
    )

    # === FPN-DRL PREDICTIONS (from your fpn_drl_predict function) ===
    fpn_signal = models.CharField(
        max_length=10,
        choices=[('BUY', 'Buy'), ('SELL', 'Sell'), ('HOLD', 'Hold')],
        default='HOLD'
    )
    fpn_confidence = models.DecimalField(
        max_digits=5, decimal_places=4, null=True, blank=True,
        help_text="FPN-DRL confidence score (0-1)"
    )
    fpn_action_probabilities = models.JSONField(
        default=dict,
        help_text="Raw action probabilities [Buy, Sell, Hold]"
    )
    fpn_model_version = models.CharField(max_length=50, blank=True, help_text="FPN model version used")

    # === CANDLESTICK PATTERNS (from your detect_candlestick_patterns) ===
    candlestick_pattern = models.CharField(
        max_length=50,
        choices=[
            ('THREE_WHITE_SOLDIERS', 'Three White Soldiers'),
            ('THREE_BLACK_CROWS', 'Three Black Crows'),
            ('MORNING_STAR', 'Morning Star'),
            ('EVENING_STAR', 'Evening Star'),
            ('BULLISH_ABANDONED_BABY', 'Bullish Abandoned Baby'),
            ('BEARISH_ABANDONED_BABY', 'Bearish Abandoned Baby'),
            ('BULLISH_KICKER', 'Bullish Kicker'),
            ('BEARISH_KICKER', 'Bearish Kicker'),
            ('NONE', 'No Pattern'),
        ],
        default='NONE'
    )
    pattern_confidence = models.DecimalField(
        max_digits=5, decimal_places=4, null=True, blank=True,
        help_text="Confidence in candlestick pattern detection"
    )

    # === FINAL TRADING SIGNAL (from your generate_trading_signals) ===
    final_signal = models.CharField(
        max_length=10,
        choices=[('BUY', 'Buy'), ('SELL', 'Sell'), ('HOLD', 'Hold')],
        default='HOLD'
    )
    signal_confidence = models.DecimalField(
        max_digits=5, decimal_places=4, null=True, blank=True,
        help_text="Overall confidence in the trading signal"
    )

    # Signal Components Breakdown
    hurst_signal = models.BooleanField(default=False, help_text="Hurst condition met")
    volatility_signal = models.BooleanField(default=False, help_text="Volatility condition met")
    regime_signal = models.BooleanField(default=False, help_text="Regime condition met")
    fpn_signal_met = models.BooleanField(default=False, help_text="FPN signal condition met")

    # Performance Tracking
    signal_executed = models.BooleanField(default=False)
    actual_return = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    prediction_error = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)

    class Meta:
        db_table = 'quantum_prediction'
        verbose_name = 'Quantum Prediction'
        verbose_name_plural = 'Quantum Predictions'
        unique_together = ['asset', 'prediction_timestamp', 'engine_config']
        indexes = [
            models.Index(fields=['asset', 'prediction_timestamp']),
            models.Index(fields=['final_signal', 'signal_confidence']),
            models.Index(fields=['created_at']),
            models.Index(fields=['hurst_exponent', 'particle_volatility']),
        ]
        ordering = ['-prediction_timestamp']

class MLModelTrainingSession(models.Model):
    """
    Tracks FPN-DRL and other ML model training sessions
    """
    engine_config = models.ForeignKey(QuantumEngineConfig, on_delete=models.CASCADE)
    model_type = models.CharField(
        max_length=50,
        choices=[
            ('FPN_DRL', 'FPN Deep Reinforcement Learning'),
            ('LSTM', 'LSTM Predictor'),
            ('ENSEMBLE', 'Ensemble Model'),
        ],
        default='FPN_DRL'
    )

    # Training Parameters
    training_data_start = models.DateTimeField()
    training_data_end = models.DateTimeField()
    features_used = models.JSONField(default=list, help_text="List of features used in training")
    hyperparameters = models.JSONField(default=dict, help_text="Model hyperparameters")

    # Training Results
    training_loss = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    validation_loss = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    training_accuracy = models.DecimalField(max_digits=5, decimal_places=4, null=True, blank=True)
    validation_accuracy = models.DecimalField(max_digits=5, decimal_places=4, null=True, blank=True)

    # Model Storage
    model_file_path = models.CharField(max_length=500, blank=True)
    model_version = models.CharField(max_length=50)
    is_production = models.BooleanField(default=False)

    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    training_duration = models.DurationField(null=True, blank=True)

    class Meta:
        db_table = 'ml_model_training_session'
        verbose_name = 'ML Model Training Session'
        verbose_name_plural = 'ML Model Training Sessions'
        indexes = [
            models.Index(fields=['model_type', 'is_production']),
            models.Index(fields=['created_at']),
        ]

class PredictionPerformance(models.Model):
    """
    Tracks performance of quantum predictions over time
    Used for model refinement and validation
    """
    quantum_prediction = models.ForeignKey(QuantumPrediction, on_delete=models.CASCADE)

    # Performance Metrics (from your calculate_metrics function)
    cumulative_return = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    sharpe_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)
    sortino_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)
    max_drawdown = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    calmar_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)

    # Trading Performance
    total_trades = models.PositiveIntegerField(default=0)
    winning_trades = models.PositiveIntegerField(default=0)
    win_rate = models.DecimalField(max_digits=5, decimal_places=4, null=True, blank=True)
    profit_factor = models.DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)

    # Benchmark Comparison
    benchmark_return = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    alpha = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)
    beta = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True)

    # Calculation Period
    evaluation_start = models.DateTimeField()
    evaluation_end = models.DateTimeField()
    calculated_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'prediction_performance'
        verbose_name = 'Prediction Performance'
        verbose_name_plural = 'Prediction Performances'
        indexes = [
            models.Index(fields=['quantum_prediction']),
            models.Index(fields=['calculated_at']),
        ]

class RealTimePredictionQueue(models.Model):
    """
    Queue system for real-time prediction processing
    """
    asset = models.ForeignKey(Asset, on_delete=models.CASCADE)
    market_data_timestamp = models.DateTimeField(help_text="Timestamp of the market data to analyze")

    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('PROCESSING', 'Processing'),
        ('COMPLETED', 'Completed'),
        ('FAILED', 'Failed'),
    ]
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='PENDING')
    priority = models.PositiveIntegerField(default=1, help_text="Processing priority (1-10, 10 highest)")

    # Processing Info
    queued_at = models.DateTimeField(auto_now_add=True)
    processing_started = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    # Results
    prediction = models.ForeignKey(QuantumPrediction, on_delete=models.SET_NULL, null=True, blank=True)
    error_message = models.TextField(blank=True)
    processing_duration = models.DurationField(null=True, blank=True)

    class Meta:
        db_table = 'real_time_prediction_queue'
        verbose_name = 'Real-time Prediction Queue'
        verbose_name_plural = 'Real-time Prediction Queues'
        indexes = [
            models.Index(fields=['status', 'priority']),
            models.Index(fields=['market_data_timestamp']),
            models.Index(fields=['queued_at']),
        ]
        ordering = ['-priority', 'queued_at']